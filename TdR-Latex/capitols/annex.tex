\section{Una solució al sudoku amb gràfics}
Podeu trobar el programa en aquest enllaç: \url{https://github.com/JordinaGR/sudoku} o escanejant el codi de la figura 6.1.
\begin{figure}[H]
    \centering
    \includegraphics[width=.15\textwidth]{capitols/figures/qr2.png}
    \caption[Programa que resol els sudokus.]{Programa que resol els sudokus. Font: elaboració pròpia.}
    \label{fig:my_label}
\end{figure}

He fet un vídeo que mostra el funcionament del programa, es pot trobar en el següent enllaç: \url{https://drive.google.com/file/d/125IrdwNMtVojWc54ez3fvlFfB3J_Ozhe/view?usp=sharing} o escanejant el codi de la figura 6.2.
\begin{figure}[H]
    \centering
    \includegraphics[width=.15\textwidth]{capitols/figures/10.png}
    \caption[Vídeo del programa que resol els sudokus.]{Vídeo del programa que resol els sudokus. Font: elaboració pròpia.}
    \label{fig:my_label}
\end{figure}

\section{Implemetació del BFS, DFS i Dijkstra}
\begin{longlisting}
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{C++}
    // Implementació del BFS en C++
    // Entrada: número de vèrtex i arestes, i les arestes (no dirigides)
    // Sortida: llista de V elements amb la distància mínima per anar del primer vèrtex 
    // a l'i-èssim.
    
    #include <bits/stdc++.h>
    using namespace std;
    
    int main() {
        int n, m; cin >> n >> m;
    
        vector<vector<int>> graph(n);
        for (int i = 0; i < m; i++){
            int u, v;
            cin >> u >> v;
            u--; v--;
    
            graph[u].push_back(v);
            graph[v].push_back(u);
        }
    
        vector<int> ans(n);
    
        for (int i = 1; i < n; i++){
            bool flag = false;
    
            vector<int> visited(n, -1);
            queue<int> q;
    
            visited[0] = 0;
            q.push(0);
    
            while (!q.empty() and !flag) {
                int p = q.front();
                q.pop();
    
                for (int nei : graph[p]){
                    if (visited[nei] == -1){
                        visited[nei] = visited[p] + 1;
                    }
                    if (nei == i){
                        ans[i] = visited[nei];
                        flag = true;
                        break;
                    }
                    q.push(nei);
                }
            }
        }
        for (auto x : ans){
            cout << x << ' ';
        } cout << endl;
    }
    \end{minted}
    \caption[Implementació del BFS en C++ en un graf no dirigit.]{Implementació del BFS en C++ en un graf no dirigit. Font: elaboració pròpia.}
    \label{Figura}
\end{longlisting}%

\begin{longlisting}
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{C++}
    // Implementació del DFS en C++
    // Entrada: número de vèrtex i arestes, i les arestes (no dirigides)
    // Sortida: si és possible arribar des del primer a l'últim vèrtex
    
    #include <bits/stdc++.h>
    using namespace std;
    
    string dfs(int start, int end, vector<bool>& visited, vector<vector<int>>& graph){
        visited[start] = true;
    
        if (start == end){
            return "SI";
        }
    
        for (int nei : graph[start]){
            if (!visited[nei]){
                return dfs(nei, end, visited, graph);
            }
        }
        return "NO";
    }
    int main(){
        int n, m; cin >> n >> m;
    
        vector<vector<int>> graph(n);
        vector<bool> visited(n, false);
    
        for (int i = 0; i < m; i++){
            int u, v;
            cin >> u >> v;
            u--; v--;
    
            graph[u].push_back(v);
            graph[v].push_back(u);
        }
    
        cout << dfs(0, n-1, visited, graph) << endl;
    }

    \end{minted}
    \caption[Implementació del DFS en C++ en un graf no dirigit.]{Implementació del DFS en C++ en un graf no dirigit. Font: elaboració pròpia.}
    \label{Figura}
\end{longlisting}%

\begin{longlisting}
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{C++}
    // Implementació del Dijkstra en C++
    // Entrada: número de vèrtex i arestes, i les arestes amb pesos (graf no dirigit)
    // Sortida: llista de V elements amb la distància mínima per anar del primer vèrtex 
    // a l'i-èssim.
    
    #include <bits/stdc++.h>
    using namespace std;
    const int INF = 1 << 30;
    
    int main(){
        ios::sync_with_stdio(false);
        cin.tie(NULL);
    
        int n, m;
        cin >> n >> m;
        vector<vector<pair<int, int>>> adj(n);
        for (int i = 0; i < m; ++i){
            int u, v, w;
            cin >> u >> v >> w;
            u--; v--;
    
            adj[u].emplace_back(w, v);
            adj[v].emplace_back(w, u);
        }
    
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        vector<int> dist(n, INF);
        pq.emplace(0, 0);
        dist[0] = 0;
    
        for (int i = 1; i < n; i++){
            pq.emplace(INF, i);
        }
    
        while (pq.size()){
            auto [c, v] = pq.top();
            pq.pop();
            if (c != dist[v]) continue;
            for (auto [w, u] : adj[v]){
                if (c + w < dist[u]){
                    dist[u] = c + w;
                    pq.emplace(dist[u], u);
                }
            }
        }
    
        for (int d : dist){
            cout << d << ' ';
        }
        cout << endl;
    }
    \end{minted}
    \caption[Implementació del Dijkstra en C++ en un graf no dirigit.]{Implementació del Dijkstra en C++ en un graf no dirigit. Font: elaboració pròpia.}
    \label{Figura}
\end{longlisting}%

\section{Implementació de la cerca lineal}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{C++}
    // Implementació en C++
    
    #include<bits/stdc++.h>
    using namespace std;

    int main(){
    	int n, k; cin >> n >> k;
    	int ans = -1;
    	
    	for (int i = 0; i < n; i++){
    		int x; cin >> x;
    		if (x == k) ans = i;
    	}
    	
    	cout << ans << endl;
    	
    }
    \end{minted}
    \caption[Implementació de cerca lineal en C++.]{Implementació de cerca lineal en C++. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}%
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{Python}
    # Implementació en Python
        
    n, k = map(int, input().split())
    ans = -1
    array = list(map(int, input().strip().split()))
    
    for i in range(n):
        if array[i] == k:
            ans = i
    
    print(ans)
    \end{minted}
    \caption[Implementació de cerca lineal en Python.]{Implementació de cerca lineal en Python. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}

\section{Implementació de la cerca dicotòmica}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{C++}
    // Implementació en C++
    
    #include <bits/stdc++.h>
    using namespace std;
    
    int binary(int l, int r, int k, vector<int> v){
        while (l <= r){
            int mid = (l+r)/2;
    
            if (v[mid] == k) return mid;
            else if (v[mid] > k) {
                r = mid-1;
            } else if (v[mid] < k) {
                l = mid+1;
            }
        }
        return -1;
    }
    int main(){
    
        int n, k; cin >> n >> k;
        vector<int> v(n);
        for (int i = 0; i < n; i++) cin >> v[i];
    
        int x = binary(0, n-1, k, v);
    
        cout << x << endl;
    }
    \end{minted}
    \caption[Implementació de la cerca dicotòmica en C++.]{Implementació de la cerca dicotòmica en C++. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{Python}
    # Implementació en Python
    
    def binary(l, r, arr):
        while l <= r:
            mid = (l+r) // 2
    
            if arr[mid] == k:
                return mid
            elif arr[mid] > k:
                r = mid-1
            elif arr[mid] < k:
                l = mid+1
    
        return -1
        
    n, k = map(int, input().split())
    array = list(map(int, input().strip().split()))
    
    x = binary(0, n-1, array)
    
    print(x)
    \end{minted}
    \caption[Implementació de la cerca dicotòmica en Python.]{Implementació de la cerca dicotòmica en Python. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}

\section{Implementació de l'ordenació de bombolla}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{C++}
    // Implementació en C++
    
    #include <bits/stdc++.h>
    using namespace std;
    
    int main(){
        int n; cin >> n;
        vector<int> v(n);
        for (int i = 0; i < n; i++){
            cin >> v[i];
        }
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n-1; j++){
                if (v[j] > v[j+1]){
                    int tmp = v[j];
                    v[j] = v[j+1];
                    v[j+1] = tmp;
                }
            }
        }
        for (auto x : v){
            cout << x << ' ';
        } cout << endl;
    }
    \end{minted}
    \caption[Implementació de l'ordenació de bombolla en C++.]{Implementació de l'ordenació de bombolla en C++. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{Python}
    # Implementació en Python
    
    n = int(input())
    arr = list(map(int, input().strip().split()))
    
    for i in range(n):
        for j in range(0, n-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    print(*arr)
    \end{minted}
    \caption[Implementació de l'ordenació de bombolla en Python.]{Implementació de l'ordenació de bombolla en Python. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}

\section{Implementació de l'ordenació per barreja}

\begin{longlisting}
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{C++}
    // Implementació en C++
    
    #include <bits/stdc++.h>
    using namespace std;
    
    void merge(vector<int>& v, int l, int mid, int r){
        vector<int> vec;
        int i = l; int j = mid+1;
    
        while (i <= mid and j <= r){
            if (v[i] < v[j]){
                vec.push_back(v[i]);
                i++;
            } else {
                vec.push_back(v[j]);
                j++;
            }
        }
        while (i <= mid){
            vec.push_back(v[i]);
            i++;
        }
        while (j <= r){
            vec.push_back(v[j]);
            j++;
        }   
        int y = 0;
        for (int q = l; q <= r; q++){
            v[q] = vec[y];
            y++; 
        }
    }
    void mergeSort(vector<int>& v, int l, int r){
        if (l < r){
            int mid = (l+r) / 2;
            mergeSort(v, l, mid);
            mergeSort(v, mid+1, r);
    
            merge(v, l, mid, r);
        }
    }
    int main(){
        int n; cin >> n;
        vector<int> v(n);
        
        for (int i = 0; i < n; i++) cin >> v[i];
    
        mergeSort(v, 0, n-1);
    
        for (auto x : v){
            cout << x << ' ';
        } cout << endl;
    }
    \end{minted}
    \caption[Implementació de l'ordenació per barreja en C++.]{Implementació de l'ordenació per barreja en C++. Font: elaboració pròpia.}
    \label{Figura}
\end{longlisting}
\begin{longlisting}
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{Python}
    # Implementació en Python
    
    def merge(arr, l, mid, r):
        b = []
        i, j = l, mid+1
    
        while i <= mid and j <= r:
            if arr[i] < arr[j]:
                b.append(arr[i])
                i += 1
            else:
                b.append(arr[j])
                j += 1
    
        while i <= mid:
            b.append(arr[i])
            i += 1
    
        while j <= r:
            b.append(arr[j])
            j += 1
    
        y = 0
        for q in range(l, r+1):
            arr[q] = b[y]
            y += 1
    
    def mergeSort(arr, l, r):
        if (l < r):
            mid = (l+r) // 2
            mergeSort(arr, l, mid)
            mergeSort(arr, mid+1, r)
    
            merge(arr, l, mid, r)
    
    
    n = int(input())
    arr = list(map(int, input().strip().split()))
    
    mergeSort(arr, 0, n-1)
    
    print(*arr)
    \end{minted}
    \caption[Implementació de l'ordenació per barreja en Python.]{Implementació de l'ordenació per barreja en Python. Font: elaboració pròpia.}
    \label{Figura}
\end{longlisting}

