\section{Una solució al sudoku amb gràfics}
El programa està en aquest enllaç: \url{https://github.com/JordinaGR/sudoku} o escanejant el codi de la figura 7.1.
\begin{figure}[H]
    \centering
    \includegraphics[width=.15\textwidth]{capitols/figures/qr2.png}
    \caption[Programa que resol els sudokus.]{Programa que resol els sudokus. Font: elaboració pròpia.}
    \label{fig:my_label}
\end{figure}

\section{Implementació de la cerca lineal}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{c++}
    // Implementació en c++
    
    #include<bits/stdc++.h>
    using namespace std;

    int main(){
    	int n, k; cin >> n >> k;
    	int ans = -1;
    	
    	for (int i = 0; i < n; i++){
    		int x; cin >> x;
    		if (x == k) ans = i;
    	}
    	
    	cout << ans << endl;
    	
    }
    \end{minted}
    \caption[Implementació de cerca lineal.]{Implementació de cerca lineal en c++. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}%
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{python}
    # Implementació en python
        
    n, k = map(int, input().split())
    ans = -1
    array = list(map(int, input().strip().split()))
    
    for i in range(n):
        if array[i] == k:
            ans = i
    
    print(ans)
    \end{minted}
    \caption[Implementació de cerca lineal.]{Implementació de cerca lineal en python. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}

\section{Implementació de la cerca dicotòmica}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{c++}
    // Implementació en c++
    #include <bits/stdc++.h>
    using namespace std;
    
    int binary(int l, int r, int k, vector<int> v){
        while (l <= r){
            int mid = (l+r)/2;
    
            if (v[mid] == k) return mid;
            else if (v[mid] > k) {
                r = mid-1;
            } else if (v[mid] < k) {
                l = mid+1;
            }
        }
        return -1;
    }
    int main(){
    
        int n, k; cin >> n >> k;
        vector<int> v(n);
        for (int i = 0; i < n; i++) cin >> v[i];
    
        int x = binary(0, n-1, k, v);
    
        cout << x << endl;
    }
    \end{minted}
    \caption[Implementació de la cerca dicotòmica en c++.]{Implementació de la cerca dicotòmica en c++. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{python}
    # Implementació en python
    def binary(l, r, arr):
        while l <= r:
            mid = (l+r) // 2
    
            if arr[mid] == k:
                return mid
            elif arr[mid] > k:
                r = mid-1
            elif arr[mid] < k:
                l = mid+1
    
        return -1
        
    n, k = map(int, input().split())
    array = list(map(int, input().strip().split()))
    
    x = binary(0, n-1, array)
    
    print(x)
    \end{minted}
    \caption[Implementació de la cerca dicotòmica en python.]{Implementació de la cerca dicotòmica en python. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}

\section{Implementació de l'ordenació de bombolla}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{c++}
    // Implementació en c++
    #include <bits/stdc++.h>
    using namespace std;
    
    int main(){
        int n; cin >> n;
        vector<int> v(n);
        for (int i = 0; i < n; i++){
            cin >> v[i];
        }
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n-1; j++){
                if (v[j] > v[j+1]){
                    int tmp = v[j];
                    v[j] = v[j+1];
                    v[j+1] = tmp;
                }
            }
        }
        for (auto x : v){
            cout << x << ' ';
        } cout << endl;
    }
    \end{minted}
    \caption[Implementació de l'ordenació de bombolla en c++.]{Implementació de l'ordenació de bombolla en c++. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}
\begin{figure}[H]
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{python}
    # Implementació en python
    n = int(input())
    arr = list(map(int, input().strip().split()))
    
    for i in range(n):
        for j in range(0, n-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    print(*arr)
    \end{minted}
    \caption[Implementació de l'ordenació de bombolla en python.]{Implementació de l'ordenació de bombolla en python. Font: elaboració pròpia.}
    \label{Figura}
\end{figure}

\section{Implementació de l'ordenació per barreja}

\begin{longlisting}
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{c++}
    // Implementació en c++
    
    #include <bits/stdc++.h>
    using namespace std;
    
    void merge(vector<int>& v, int l, int mid, int r){
        vector<int> vec;
        int i = l; int j = mid+1;
    
        while (i <= mid and j <= r){
            if (v[i] < v[j]){
                vec.push_back(v[i]);
                i++;
            } else {
                vec.push_back(v[j]);
                j++;
            }
        }
        while (i <= mid){
            vec.push_back(v[i]);
            i++;
        }
        while (j <= r){
            vec.push_back(v[j]);
            j++;
        }   
        int y = 0;
        for (int q = l; q <= r; q++){
            v[q] = vec[y];
            y++; 
        }
    }
    void mergeSort(vector<int>& v, int l, int r){
        if (l < r){
            int mid = (l+r) / 2;
            mergeSort(v, l, mid);
            mergeSort(v, mid+1, r);
    
            merge(v, l, mid, r);
        }
    }
    int main(){
        int n; cin >> n;
        vector<int> v(n);
        
        for (int i = 0; i < n; i++) cin >> v[i];
    
        mergeSort(v, 0, n-1);
    
        for (auto x : v){
            cout << x << ' ';
        } cout << endl;
    }
    \end{minted}
    \caption[Implementació de l'ordenació per barreja en c++.]{Implementació de l'ordenació per barreja en c++. Font: elaboració pròpia.}
    \label{Figura}
\end{longlisting}
\begin{longlisting}
    \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=LightGray,
    fontsize=\footnotesize,
    linenos
    ]{python}
    # Implementació en python
    
    def merge(arr, l, mid, r):
        b = []
        i, j = l, mid+1
    
        while i <= mid and j <= r:
            if arr[i] < arr[j]:
                b.append(arr[i])
                i += 1
            else:
                b.append(arr[j])
                j += 1
    
        while i <= mid:
            b.append(arr[i])
            i += 1
    
        while j <= r:
            b.append(arr[j])
            j += 1
    
        y = 0
        for q in range(l, r+1):
            arr[q] = b[y]
            y += 1
    
    def mergeSort(arr, l, r):
        if (l < r):
            mid = (l+r) // 2
            mergeSort(arr, l, mid)
            mergeSort(arr, mid+1, r)
    
            merge(arr, l, mid, r)
    
    
    n = int(input())
    arr = list(map(int, input().strip().split()))
    
    mergeSort(arr, 0, n-1)
    
    print(*arr)
    \end{minted}
    \caption[Implementació de l'ordenació per barreja en python.]{Implementació de l'ordenació per barreja en python. Font: elaboració pròpia.}
    \label{Figura}
\end{longlisting}
